Require Import Lists.List.
Require Import Lists.ListSet.
Require Import Strings.String.
Import ListNotations.

Require Import syntax.
Require Import semantics_sos.

(** LTS RELATION **)

Inductive transitionR : specification -> (proc_body * event_tau_tick * proc_body) -> proc_body -> Prop :=
  | transition_rule (C : specification) (P' : proc_body) (a : event_tau_tick) (Q : proc_body)
    (P : proc_body)  (Tc : list event_tau_tick) :
      (C # P /// Tc ==> P') ->
      (C # P' // a ==> Q) ->
      transitionR C (P', a, Q) P.

Local Open Scope string.

Definition TOY_PROBLEM := Spec [Channel {{"a", "b"}}] ["P" ::= "a" --> "b" --> STOP].

Example test1 : transitionR TOY_PROBLEM ("a" --> "b" --> STOP, Event "a", "b" --> STOP) ("a" --> "b" --> STOP).
Proof.
  apply transition_rule with (Tc := nil).
  - apply sos_empty_rule.
  - apply prefix_rule.
Qed.

Example test2 : transitionR TOY_PROBLEM ("b" --> STOP, Event "b", STOP) ("a" --> "b" --> STOP).
Proof.
  apply transition_rule with (Tc := [Event "a"]).
  - apply sos_transitive_rule with (R := "b" --> STOP).
    * apply prefix_rule.
    * apply sos_empty_rule.
  - apply prefix_rule.
Qed.

Inductive transitionsR : specification -> list (proc_body * event_tau_tick * proc_body) -> proc_body -> Prop :=
  | transitions_empty_rule (C : specification) (P : proc_body) :
      transitionsR C nil P
  | transitions_rule (C : specification) (P : proc_body) (head : proc_body * event_tau_tick * proc_body)
    (tail : list (proc_body * event_tau_tick * proc_body)) :
      transitionR C head P ->
      transitionsR C tail P ->
      transitionsR C (head :: tail) P.

Example test3 :
  transitionsR
    TOY_PROBLEM 
    [
      ("b" --> STOP, Event "b", STOP)
      ; ("a" --> "b" --> STOP, Event "a", "b" --> STOP)
    ] 
    ("a" --> "b" --> STOP).
Proof.
  apply transitions_rule.
  - apply transition_rule with (Tc := [Event "a"]).
    * apply sos_transitive_rule with (R := "b" --> STOP).
      + apply prefix_rule.
      + apply sos_empty_rule.
    * apply prefix_rule.
  - apply transitions_rule.
    * apply transition_rule with (Tc := nil).
      + apply sos_empty_rule.
      + apply prefix_rule.
    * apply transitions_empty_rule.
Qed.

Inductive ltsR (C : specification) (T : list (proc_body * event_tau_tick * proc_body)) (P : proc_body) : Prop :=
  | lts_rule :
      (forall (t : proc_body * event_tau_tick * proc_body), transitionR C t P -> In t T) ->
      transitionsR C T P ->
      ltsR C T P.

(* TODO Complete this proof. *)
Example lts1 :
  ltsR TOY_PROBLEM [("a" --> STOP, Event "a", STOP)] ("a" --> STOP).
Proof.
    apply lts_rule.
    - intros. destruct H. simpl. left. Abort.

Lemma event_eq_dec_imp :
  forall (e1 e2 : event),
    {e1 = e2} + {e1 <> e2} ->
    e1 = e2 \/ e1 <> e2.
Proof.
  intros. destruct H.
  - left. apply e.
  - right. apply n.
Qed.

Theorem event_tau_tick_eq_dec :
  forall (e1 e2 : event_tau_tick),
    {e1 = e2} + {e1 <> e2}.
Proof.
  intros. destruct e1, e2 ; try (left ; reflexivity) ;
  try (right ; unfold not ; intros H ; now inversion H).
  assert (H : e = e0 \/ e <> e0). {
    apply event_eq_dec_imp. apply event
  
  
  assert (H : e = e0 \/ e <> e0). { apply event_eq_dec. }.
    induction e.
    - destruct e0.
      + left. reflexivity.
      + right. unfold not. intros H. inversion H.
    - induction e0.
      + right. unfold not. intros H. inversion H.
      + destruct IHe.
         rewrite H in IHe0. rewrite H.
  
   apply event_dec. }
  

  

Theorem transition_eq_dec :
  forall (t1 t2 : (proc_body * event_tau_tick * proc_body)),
    {t1 = t2} + {t1 <> t2}.
Proof.
  intros. induction t1, t2, a

  intros. destruct t1 as [p1 p1']. destruct p1 as [p1 a].
  destruct t2 as [p2 p2']. destruct p2 as [p2 a'].
  destruct a, a' ; try (right ; unfold not ; intros H ; now inversion H).
  - admit. 
  - destruct p1, p2 ; try (right ; unfold not ; intros H ; now inversion H).
    destruct p1', p2' ; try (right ; unfold not ; intros H ; now inversion H) ;
    try (left ; now reflexivity).
    + Print string_dec.

  
  
   
  induction p1, p2 ; try (right ; unfold not ; intros H ; now inversion H).
  induction p1', p2' ; try (right ; unfold not ; intros H ; now inversion H).
  destruct a, a' ; try (right ; unfold not ; intros H ; now inversion H).
  try (left ; now reflexivity).
  
  eapply prod_eqdec.
  - unfold EqDec. intros. destruct x,y.
    + left. reflexivity.


Theorem transition_eq_dec :
  forall (t1 t2 : (proc_body * event_tau_tick * proc_body)),
    {t1 = t2} + {t1 <> t2}.
Proof.
  intros. destruct t1. destruct p. destruct t2. destruct p1.
  apply prod_eqdec.
  apply prod_eqdec with (A := (p,e)) (y := p0).
  - eapply prod_eqdec.
    + 
  
  unfold sumbool.


Inductive ltsR' : specification -> set (proc_body * event_tau_tick * proc_body) -> set proc_body -> Prop :=
  | lts_empty_rule (C : specification) (S : set proc_body) (P : proc_body) :
    Datatypes.length S = 1 ->
    In P S ->
    ~ (exists (a : event_tau_tick) (P' : proc_body), C # P // a ==> P') ->
    ltsR' C nil S
  | lts_inductive_rule (C : specification) (T T' : set (proc_body * event_tau_tick * proc_body)) (P : proc_body) (L : set proc_body) :
    ~ In P L ->
    ltsR' C T L ->
    (forall (a : event_tau_tick) (P' : proc_body), (C # P // a ==> P') <-> In (P,a,P') T') ->
    ltsR' C (set_union T' T) (set_union [P] L).
    
    exists (T' : list (proc_body * event_tau_tick * proc_body)),
      forall (a : event_tau_tick) (P' : proc_body), C # P // a ==> P' <-> In (P,a,P') T'
      
    ltsR' C ( (P,a,P) :: T) P.

Local Close Scope string.