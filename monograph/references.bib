@InProceedings{pierce:quickchick,
	author="Paraskevopoulou, Zoe
	and Hri{\c{t}}cu, C{\u{a}}t{\u{a}}lin
	and D{\'e}n{\`e}s, Maxime
	and Lampropoulos, Leonidas
	and Pierce, Benjamin C.",
	editor="Urban, Christian
	and Zhang, Xingyuan",
	title="Foundational Property-Based Testing",
	booktitle="Interactive Theorem Proving",
	year="2015",
	publisher="Springer International Publishing",
	address="Cham",
	pages="325--343",
	isbn="978-3-319-22102-1"
}

@book{roscoe:ucs,
	author = {Roscoe, A.W.},
	title = {Understanding Concurrent Systems},
	year = {2010},
	isbn = {184882257X},
	publisher = {Springer-Verlag},
	address = {Berlin, Heidelberg},
	edition = {1st},
	abstract = {CSP notation has been used extensively for teaching and applying concurrency theory, ever since the publication of the text Communicating Sequential Processes by C.A.R. Hoare in 1985. Both a programming language and a specification language, the theory of CSP helps users to understand concurrent systems, and to decide whether a program meets its specification. As a member of the family of process algebras, the concepts of communication and interaction are presented in an algebraic style. An invaluable reference on the state of the art in CSP, Understanding Concurrent Systems also serves as a comprehensive introduction to the field, in addition to providing material for a number of more advanced courses. A first point of reference for anyone wanting to use CSP or learn about its theory, the book also introduces other views of concurrency, using CSP to model and explain these. The text is fully integrated with CSP-based tools such as FDR, and describes how to create new tools based on FDR. Most of the book relies on no theoretical background other than a basic knowledge of sets and sequences. Sophisticated mathematical arguments are avoided whenever possible. Topics and features: presents a comprehensive introduction to CSP; discusses the latest advances in CSP, covering topics of operational semantics, denotational models, finite observation models and infinite-behaviour models, and algebraic semantics; explores the practical application of CSP, including timed modelling, discrete modelling, parameterised verifications and the state explosion problem, and advanced topics in the use of FDR; examines the ability of CSP to describe and enable reasoning about parallel systems modelled in other paradigms; covers a broad variety of concurrent systems, including combinatorial, timed, priority-based, mobile, shared variable, statecharts, buffered and asynchronous systems; contains exercises and case studies to support the text; supplies further tools and information at the associated website: http://www.comlab.ox.ac.uk/ucs/. From undergraduate students of computer science in need of an introduction to the area, to researchers and practitioners desiring a more in-depth understanding of theory and practice of concurrent systems, this broad-ranging text/reference is essential reading for anyone interested in Hoares CSP.}
}

@book{bertot:coq,
	author = {Bertot, Yves and Castran, Pierre},
	title = {Interactive Theorem Proving and Program Development: Coq'Art The Calculus of Inductive Constructions},
	year = {2010},
	isbn = {3642058809},
	publisher = {Springer Publishing Company, Incorporated},
	edition = {1st},
	abstract = {A practical introduction to the development of proofs and certified programs using Coq. An invaluable tool for researchers, students, and engineers interested in formal methods and the development of zero-fault software.}
}

@inproceedings{brady:idris,
	author = {Brady, Edwin C.},
	title = {IDRIS ---: Systems Programming Meets Full Dependent Types},
	year = {2011},
	isbn = {9781450304870},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/1929529.1929536},
	doi = {10.1145/1929529.1929536},
	abstract = {Dependent types have emerged in recent years as a promising approach to ensuring program correctness. However, existing dependently typed languages such as Agda and Coq work at a very high level of abstraction, making it difficult to map verified programs to suitably efficient executable code. This is particularly problematic for programs which work with bit level data, e.g. network packet processing, binary file formats or operating system services. Such programs, being fundamental to the operation of computers in general, may stand to benefit significantly from program verification techniques. This paper describes the use of a dependently typed programming language, Idris, for specifying and verifying properties of low-level systems programs, taking network packet processing as an extended example. We give an overview of the distinctive features of Idris which allow it to interact with external systems code, with precise types. Furthermore, we show how to integrate tactic scripts and plugin decision procedures to reduce the burden of proof on application developers. The ideas we present are readily adaptable to languages with related type systems.},
	booktitle = {Proceedings of the 5th ACM Workshop on Programming Languages Meets Program Verification},
	pages = {43–54},
	numpages = {12},
	keywords = {data description, dependent types},
	location = {Austin, Texas, USA},
	series = {PLPV '11}
}

@inproceedings{rushby:pvs,
	AUTHOR = {{S.} Owre and {J.} {M.} Rushby and and {N.} Shankar},
	TITLE = {{PVS:} {A} Prototype Verification System},
	BOOKTITLE = {11th International Conference on Automated Deduction (CADE)},
	YEAR = {1992},
	EDITOR = {Deepak Kapur},
	SERIES = {Lecture Notes in Artificial Intelligence},
	VOLUME = {607},
	PAGES = {748--752},
	ADDRESS = {Saratoga, {NY}},
	MONTH = {jun},
	PUBLISHER = {Springer-Verlag},
	URL = {http://www.csl.sri.com/papers/cade92-pvs/}
}

@phdthesis{norell:thesis,
	author  = {Ulf Norell},
	title	  = {Towards a practical programming language based on dependent type
	theory},
	school  = {Department of Computer Science and Engineering, Chalmers University of Technology},
	year	  = 2007,
	month	  = {September},
	address = {SE-412 96 G\"{o}teborg, Sweden}
}

@book{nipkow:isabelle,
	author = {Nipkow, Tobias and Wenzel, Markus and Paulson, Lawrence C.},
	title = {Isabelle/HOL: A Proof Assistant for Higher-Order Logic},
	year = {2002},
	isbn = {3540433767},
	publisher = {Springer-Verlag},
	address = {Berlin, Heidelberg}
}

@book{schneider1999,
	author = {Schneider, Steve},
	title = {Concurrent and Real Time Systems: The {CSP} Approach},
	year = {1999},
	isbn = {0471623733},
	publisher = {John Wiley \& Sons, Inc.},
	address = {USA},
	edition = {1st}}

@inproceedings{hughes:quickcheck2000,
	author = {Claessen, Koen and Hughes, John},
	title = {QuickCheck: A Lightweight Tool for Random Testing of Haskell Programs},
	year = {2000},
	isbn = {1581132026},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/351240.351266},
	doi = {10.1145/351240.351266},
	abstract = {Quick Check is a tool which aids the Haskell programmer in formulating and testing properties of programs. Properties are described as Haskell functions, and can be automatically tested on random input, but it is also possible to define custom test data generators. We present a number of case studies, in which the tool was successfully used, and also point out some pitfalls to avoid. Random testing is especially suitable for functional programs because properties can be stated at a fine grain. When a function is built from separately tested components, then random testing suffices to obtain good coverage of the definition under test.},
	booktitle = {Proceedings of the Fifth ACM SIGPLAN International Conference on Functional Programming},
	pages = {268–279},
	numpages = {12},
	series = {ICFP '00}
}

@article{hoare:csp,
	title={Communicating sequential processes},
	author={Hoare, Charles Antony Richard},
	journal={Communications of the ACM},
	volume={21},
	number={8},
	pages={666--677},
	year={1978},
	publisher={ACM New York, NY, USA}
}

@book {Lampropoulos:SF4,
	author = {Leonidas Lampropoulos and Benjamin C. Pierce},
	title = "QuickChick: Property-Based Testing in Coq",
	series = "Software Foundations",
	volume = "4",
	year = "2020",
	publisher = "Electronic textbook",
	note = {Version 1.1, \url{http://softwarefoundations.cis.upenn.edu} },
}

@InProceedings{Roggenbach:CSP-Prover,
	author="Isobe, Yoshinao
	and Roggenbach, Markus",
	editor="Halbwachs, Nicolas
	and Zuck, Lenore D.",
	title="A Generic Theorem Prover of CSP Refinement",
	booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
	year="2005",
	publisher="Springer Berlin Heidelberg",
	address="Berlin, Heidelberg",
	pages="108--123",
	abstract="We describe a new tool called Csp-Prover which is an interactive theorem prover dedicated to refinement proofs within the process algebra Csp. It aims specifically at proofs for infinite state systems, which may also involve infinite non-determinism. Semantically, Csp-Prover supports both the theory of complete metric spaces as well as the theory of complete partial orders. Both these theories are implemented for infinite product spaces. Technically, Csp-Prover is based on the theorem prover Isabelle. It provides a deep encoding of Csp. The tool's architecture follows a generic approach which makes it easy to adapt it for various Csp models besides those studied here: the stable failures model {\$}{\backslash}mathcal{\{}F{\}}{\$}and the traces model {\$}{\backslash}mathcal{\{}T{\}}{\$}.",
	isbn="978-3-540-31980-1"
}

@InProceedings{Woodcock:Isabelle/UTP,
	author="Foster, Simon
	and Zeyda, Frank
	and Woodcock, Jim",
	editor="Naumann, David",
	title="Isabelle/UTP: A Mechanised Theory Engineering Framework",
	booktitle="Unifying Theories of Programming",
	year="2015",
	publisher="Springer International Publishing",
	address="Cham",
	pages="21--41",
	abstract="We introduce Isabelle/UTP, a novel mechanisation of Hoare and He's Unifying Theories of Programming (UTP) in Isabelle/HOL. UTP is a framework for the study, formalisation, and unification of formal semantics. Our contributions are, firstly, a deep semantic model of UTP's alphabetised predicates, supporting meta-logical reasoning that is parametric in the underlying notions of values and types. Secondly, integration of host-logic type checking that subsumes the need for typing proof obligations in the object-language. Thirdly, proof tactics that transfer results from well-supported mathematical structures in Isabelle to proofs about UTP theories. Additionally, our work provides novel insights towards reconciliation of shallow and deep language embeddings.",
	isbn="978-3-319-14806-9"
}

@book{Paulson:Isabelle,
	title={Isabelle: A generic theorem prover},
	author={Paulson, Lawrence C},
	volume={828},
	year={1994},
	publisher={Springer Science \& Business Media}
}